네임스페이스
참조자(레퍼런스): 생성과 동시에 초기화 되어야 함, 처음에 누구의 별명이 될 것인지 정해야 한다. 한번 별명이 되면 다른 변수의 별명이 될 수 없다.
메모리 관리
배열 메모리 관리
함수 오버로딩(규칙)
클래스
생성자
디폴트 생성자
생성자 오버로딩
new -> 메모리 동적 할당 + 객체 생성자 호출
소멸자: 오버로딩x, 인자x, 주로 객체의 할당된 메모리 해제에 사용
디폴트 소멸자
복사 생성자: 인자로 객체 넘겨 복사 생성자 호출, 생성 시에만 호출
디폴트 복사 생성자: 다른 디폴트와 달리 실제로 복사를 수행한다. <- 얖은 복사
디폴트 복사 생성자의 한계: 동적 할당 메모리의 경우 소멸자에서 두번 해제하기 때문에 오류 발생
깊은 복사: 메모리를 새로 할당해서 내용을 복사
-> 컴파일러는 얕은 복사만 해준다.


초기화 리스트: 생성자 호출과 동시에 멤버 변수 초기화
 - 생성과 초기화를 동시에, 즉 생성 후 대입보다 효율적이다.

클래스에 참조자나 상수를 넣고 싶으면 생성자에서 무조건 초기화 리스트를 사용해 초기화 해야 한다.
 - 바뀌면 안되는 중요한 값들은 상수로 처리한다.

static 멤버 변수: 클래스 하나에만 종속되는 변수
 - 객체나 함수가 종료될 때 소멸되는 것이 아닌 프로그램 종료 시 소멸되는 변수
 - 모든 클래스의 객체들이 공유

const static 변수일 경우에만 클래스 멤버변수를 선언과 동시에 초기화할 수 있다.
 - class test{ const static int x = 0; }

클래스 static 변수: 클래스 자체에 딱 1개 존재하는 함수, 객체에 종속 x, 클래스에 종속 o
 - 객체가 없어도 클래스 자체에서 호출 가능
 - (클래스)::(static 함수)
 - 클래스 static 함수는 클래스의 static 변수만 이용할 수 있다.


this: 객체 자신을 가리키는 포인터 역할
레퍼런스 타입 반환
 - return *this : this는 함수를 호출한 객체를 가리키기에 *this는 객체 자신을 의미하기 때문에
		(클래스&) 를 반환 타입으로 설정해 자기 자신을 반환할 수 있게 한다.(레퍼런스가 아닌 경우에는 복사된 임시 객체가 반환되기 때문에 자기 자신이라 볼 수 없다.)
		*this인 이유는 this가 자기 자신을 가리키는 포인터 이기 때문에 *을 붙여 메모리 주소가 아닌 주소에 위치한 객체를 나타낸다.


const 함수(상수 함수): 변수들의 값을 바꾸지 않고 읽기만 하는 함수
 - (자료형) (함수)() const {} : 상수 멤버 함수의 선언
 - 다른 변수의 값을 바꾸지 않는 함수(읽기만 수행)
 - 상수 함수 내에서 호출할 수 있는 함수로는 다른 상수 함수밖에 없다.




